(use Array)
(use Map)

(defmodule Sheriff
  (defmodule JSON
    (deftype DSL (Node [String]))

    (defmodule DSL
      (sig stringify (Fn [DSL] String))
      (defn stringify [n] (match n (Node v) v))

      (defn escape-string [s]
        (let [sub $[(Pair.init @#"\\" @"\\\\\\\\")
                    (Pair.init @#"\"" @"\\\\\"")
                    (Pair.init @#"'" @"\\\\'")
                    (Pair.init @#"\t" @"\\\\t")
                    (Pair.init (Pattern.init "\b") @"\\\\b")
                    (Pair.init (Pattern.init "\f") @"\\\\f")
                    (Pair.init @#"\r" @"\\\\r")
                    (Pair.init @#"\n" @"\\\\n")]]
          (StaticArray.reduce
           &(fn [acc pair]
             (Pattern.substitute (Pair.a pair) &acc (Pair.b pair) -1))
           s
           sub)))

      (sig s (Fn [String] DSL))
      (defn s [string] (Node (fmt "\"%s\"" &(escape-string string))))

      (sig n (Fn [Double] DSL))
      (defn n [double] (Node (fmt "%.16g" double)))

      (sig b (Fn [Bool] DSL))
      (defn b [boolean] (Node (Bool.str boolean)))

      (sig a (Fn [(Array DSL)] DSL))
      (defn a [arr]
        (Node
          (fmt "[%s]" &(String.join ", " &(copy-map
                                           &(fn [n] (stringify @n))
                                           &(the (Array DSL) arr))))))

      (hidden make-kv)
      (private make-kv)
      (sig make-kv (Fn [(Pair String Node)] String))
      (defn make-kv [arg]
        (fmt "\"%s\": %s"
             (the (Ref String) (Pair.a arg))
             &(stringify @(Pair.b arg))))

      (sig o (Fn [(Map String DSL)] DSL))
      (defn o [m]
        (Node
          (fmt "{%s}" &(==> (to-array &(the (Map String DSL) m))
                            (ref)
                            (copy-map &Sheriff.JSON.DSL.make-kv)
                            (ref)
                            (String.join ", ")))))

      (sig null (Fn [] DSL))
      (defn null [] (Node @"null")))))
