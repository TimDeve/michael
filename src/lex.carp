(use Result)

(defmodule Sheriff
 (defmodule JSON
  (defmodule Lexer
    (deftype Token
     LeftCurly
     RightCurly
     LeftBracket
     RightBracket
     Colon
     Comma
     Null
     (Str [String])
     (Bol [String])
     (Num [String]))

    (use Token)

    (defn is-white-space? [char]
      (StaticArray.any? &(fn [c] (= char c)) $[\space \tab \newline]))

    (defn true? [b] @b)

    (defn is-null? [i chrs]
      (StaticArray.all? &true?
                        $[(= \n @(Array.unsafe-nth chrs i))
                          (= \u @(Array.unsafe-nth chrs (+ 1 i)))
                          (= \l @(Array.unsafe-nth chrs (+ 2 i)))
                          (= \l @(Array.unsafe-nth chrs (+ 3 i)))]))

    (defn lex-number [i chrs]
      (let [error false char-str (the (Array Char) [])]
        (do
          (while (< i (Array.length chrs))
            (do
             (let [char (the (Ref Char) (Array.unsafe-nth chrs i))]
              (if (not (StaticArray.any? &(fn [c] (= char c))
                                         $[\0 \1 \2 \3 \4 \5 \6 \7 \8 \9 \e \.]))
                (break)
                (Array.push-back! &char-str @char)))
             (update! i inc)
             (if (= i (Array.length chrs)) (set! error true) ())))
          (if error
            (Error @"Unexpected end of input")
            (Success (Pair.init i (Num (String.from-chars &char-str))))))))

    (defn lex-string [i chrs]
      (let [error false char-str (the (Array Char) [])]
        (do
          (while (< i (Array.length chrs))
            (do
             (let [char @(Array.unsafe-nth chrs i)]
              (if (and (= \" char) (not (= \\ @(Array.unsafe-nth chrs (- i 1)))))
                (break)
                (Array.push-back! &char-str char)))
             (update! i inc)
             (if (= i (Array.length chrs)) (set! error true) ())))
          (if error
            (Error @"Unmatched double-quote")
            (Success (Pair.init i (Str (String.from-chars &char-str))))))))

    ;(sig lex-i (Fn [Int (Ref Array Char) (Result (Array Token) String)] (Result (Array Token) String)))
    (defn lex-i [i chrs res-toks]
      (match res-toks
        (Error e) (Error e)
        (Success toks)
        (if (>= i (Array.length chrs))
          (Success toks)
          (let [current-char (Array.unsafe-nth chrs i)]
            (if (is-white-space? current-char)
              (lex-i (inc i) chrs (the (Result (Array Token) String) (Success toks)))
              (if (Char.num? @current-char)
                (let [num-pair (lex-number i chrs)]
                 (match num-pair
                   (Error e) (Error e)
                   (Success pair)
                   (lex-i (inc @(Pair.a &pair))
                       chrs
                       (the (Result (Array Token) String)
                        (Success (Array.push-back toks @(Pair.b &pair)))))))
                (case @current-char
                  \{ (lex-i (inc i)
                            chrs
                            (the (Result (Array Token) String)
                             (Success (Array.push-back toks (LeftCurly)))))
                  \} (lex-i (inc i)
                            chrs
                            (the (Result (Array Token) String)
                             (Success (Array.push-back toks (RightCurly)))))
                  \[ (lex-i (inc i)
                            chrs
                            (the (Result (Array Token) String)
                             (Success (Array.push-back toks (LeftBracket)))))
                  \] (lex-i (inc i)
                            chrs
                            (the (Result (Array Token) String)
                             (Success (Array.push-back toks (RightBracket)))))
                  \: (lex-i (inc i)
                            chrs
                            (the (Result (Array Token) String)
                             (Success (Array.push-back toks (Colon)))))
                  \n (if (not (is-null? i chrs))
                       (Error @"Failed to lex null token")
                       (lex-i (+ 5 i)
                              chrs
                              (the (Result (Array Token) String)
                               (Success (Array.push-back toks (Null))))))
                  \" (let [string-pair (lex-string (inc i) chrs)]
                      (match string-pair
                        (Error e) (Error e)
                        (Success pair)
                        (lex-i (inc @(Pair.a &pair))
                            chrs
                            (the (Result (Array Token) String)
                             (Success (Array.push-back toks @(Pair.b &pair)))))))
                 (Error (String.append "Unexpect char = " &(str @current-char))))))))))

    (sig lex (Fn [(Ref String)] (Result (Array Token) String)))
    (defn lex [s]
     (the (Result (Array Token) String)
      (let [chrs (chars s)]
       (lex-i 0
              &chrs
              (the (Result (Array Token) String)
                   (Success [])))))))))

