(use Result)

(defmodule Sheriff
 (defmodule JSON
  (defmodule Lexer
    (deftype Token
     LeftCurly
     RightCurly
     LeftBracket
     RightBracket
     Colon
     Comma
     Null
     (Str [String])
     (Bol [Bool])
     (Num [String]))

    (defmodule Token
     (defn to-int [t]
      (match-ref t
       LeftCurly 0
       RightCurly 1
       LeftBracket 2
       RightBracket 3
       Colon 4
       Comma 5
       Null 6
       (Str _) 7
       (Bol _) 8
       (Num _) 9))

     (defn is-a [a b]
      (Int.= (to-int a) (to-int b))))

    (use Token)

    (defn is-white-space? [char]
      (StaticArray.any? &(fn [c] (= char c)) $[\space \tab \newline \return]))

    (defn true? [b] @b)

    (defn is-null? [i chrs]
      (if (< (+ i 3) (Array.length chrs))
        (StaticArray.all? &true?
                          $[(= \n @(Array.unsafe-nth chrs i))
                            (= \u @(Array.unsafe-nth chrs (+ 1 i)))
                            (= \l @(Array.unsafe-nth chrs (+ 2 i)))
                            (= \l @(Array.unsafe-nth chrs (+ 3 i)))])
        false))

    (defn is-true? [i chrs]
      (if (< (+ i 3) (Array.length chrs))
        (StaticArray.all? &true?
                          $[(= \t @(Array.unsafe-nth chrs i))
                            (= \r @(Array.unsafe-nth chrs (+ 1 i)))
                            (= \u @(Array.unsafe-nth chrs (+ 2 i)))
                            (= \e @(Array.unsafe-nth chrs (+ 3 i)))])
        false))

    (defn is-false? [i chrs]
      (if (< (+ i 4) (Array.length chrs))
        (StaticArray.all? &true?
                          $[(= \f @(Array.unsafe-nth chrs i))
                            (= \a @(Array.unsafe-nth chrs (+ 1 i)))
                            (= \l @(Array.unsafe-nth chrs (+ 2 i)))
                            (= \s @(Array.unsafe-nth chrs (+ 3 i)))
                            (= \e @(Array.unsafe-nth chrs (+ 4 i)))])
        false))

    (defn lex-number [i chrs]
      (let-do [done false char-str (the (Array Char) [])]
        (while-do (and (< i (Array.length chrs))
                       (not done))
          (let [char (the (Ref Char) (Array.unsafe-nth chrs i))]
            (if (not (StaticArray.any? &(fn [c] (= char c))
                                       $[\0 \1 \2 \3 \4 \5 \6 \7 \8 \9 \e \.]))
              (set! done true)
              (do
                (Array.push-back! &char-str @char)
                (update! i inc)))))
        (Success (Pair.init i (Num (String.from-chars &char-str))))))

    (defn lex-string [i chrs]
      (let [error false done false char-str (the (Array Char) [])]
        (do
          (while (and (< i (Array.length chrs))
                      (not done))
           (let [char @(Array.unsafe-nth chrs i)]
            (if (and (= \" char) (not (= \\ @(Array.unsafe-nth chrs (- i 1)))))
              (set! done true)
              (do
                (Array.push-back! &char-str char)
                (update! i inc)
                (if (= i (Array.length chrs)) (set! error true) ())))))
          (if error
            (Error @"Unmatched double-quote")
            (Success (Pair.init i (Str (String.from-chars &char-str))))))))

    ;(sig lex-i (Fn [Int (Ref Array Char) (Result (Array Token) String)] (Result (Array Token) String)))
    (defn lex-i [i chrs res-toks]
      (match res-toks
        (Error e) (Error e)
        (Success toks)
        (if (>= i (Array.length chrs))
          (Success toks)
          (let [current-char (Array.unsafe-nth chrs i)]
            (if (is-white-space? current-char)
              (lex-i (inc i) chrs (the (Result (Array Token) String) (Success toks)))
              (if (Char.num? @current-char)
                (let [num-pair (lex-number i chrs)]
                 (match num-pair
                   (Error e) (Error e)
                   (Success pair)
                   (lex-i @(Pair.a &pair)
                       chrs
                       (the (Result (Array Token) String)
                        (Success (Array.push-back toks @(Pair.b &pair)))))))
                (case @current-char
                  \{ (lex-i (inc i)
                            chrs
                            (the (Result (Array Token) String)
                             (Success (Array.push-back toks (LeftCurly)))))
                  \} (lex-i (inc i)
                            chrs
                            (the (Result (Array Token) String)
                             (Success (Array.push-back toks (RightCurly)))))
                  \[ (lex-i (inc i)
                            chrs
                            (the (Result (Array Token) String)
                             (Success (Array.push-back toks (LeftBracket)))))
                  \] (lex-i (inc i)
                            chrs
                            (the (Result (Array Token) String)
                             (Success (Array.push-back toks (RightBracket)))))
                  \: (lex-i (inc i)
                            chrs
                            (the (Result (Array Token) String)
                             (Success (Array.push-back toks (Colon)))))
                  \, (lex-i (inc i)
                            chrs
                            (the (Result (Array Token) String)
                             (Success (Array.push-back toks (Comma)))))
                  \n (if (not (is-null? i chrs))
                       (Error @"Failed to lex null token")
                       (lex-i (+ 4 i)
                              chrs
                              (the (Result (Array Token) String)
                               (Success (Array.push-back toks (Null))))))
                  \t (if (not (is-true? i chrs))
                       (Error @"Failed to lex true token")
                       (lex-i (+ 4 i)
                              chrs
                              (the (Result (Array Token) String)
                               (Success (Array.push-back toks (Bol true))))))
                  \f (if (not (is-false? i chrs))
                       (Error @"Failed to lex false token")
                       (lex-i (+ 5 i)
                              chrs
                              (the (Result (Array Token) String)
                               (Success (Array.push-back toks (Bol false))))))
                  \" (let [string-pair (lex-string (inc i) chrs)]
                      (match string-pair
                        (Error e) (Error e)
                        (Success pair)
                        (lex-i (inc @(Pair.a &pair))
                            chrs
                            (the (Result (Array Token) String)
                             (Success (Array.push-back toks @(Pair.b &pair)))))))
                 (Error (String.append "Unexpect char = " &(str @current-char))))))))))

    (sig lex (Fn [(Ref String)] (Result (Array Token) String)))
    (defn lex [s]
     (the (Result (Array Token) String)
      (let [chrs (chars s)]
       (lex-i 0
              &chrs
              (the (Result (Array Token) String)
                   (Success [])))))))))

