(load "./lex.carp")

(use Maybe)
(use Result)

(deftype SheriffJsonNode
 (Bol [Bool])
 (Str [String])
 (Num [Double])
 (Obj [(Map String Int)])
 (Arr [(Array Int)])
 Null)

(deftype SheriffJSON [data (Array SheriffJsonNode)])

(defmodule SheriffJSON
  (defn unsafe-at [json i]
   (Array.unsafe-nth (data json) i))

  (defn push-jnode! [json node]
    (do
     (Array.push-back! (data json) node)
     (- (Array.length (data json)) 1)))

  (defn put-obj! [json obj-i key node]
    (let [new-i (push-jnode! json node) maybe-map (unsafe-at json obj-i)]
      (match-ref maybe-map
        (SheriffJsonNode.Obj m)  (Map.put! m key &new-i)
        (SheriffJsonNode.Str st) ()
        (SheriffJsonNode.Num nu) ()
        (SheriffJsonNode.Bol b)  ()
        (SheriffJsonNode.Arr a)  ()
        SheriffJsonNode.Null     ())))

  (defn parse-object [i toks json]
    (let-do [error (Nothing) obj-i (push-jnode! json (SheriffJsonNode.Obj {}))]
      (while-do (and (< i (- (Array.length toks) 3))
                     (not (just? &error)))
        (let [key (Array.unsafe-nth toks i)
              colon (Array.unsafe-nth toks (+ i 1))
              value (Array.unsafe-nth toks (+ i 2))
              sep (Array.unsafe-nth toks (+ i 3))]
          (match @colon
           SheriffTok.Colon
           (match @key
            (SheriffTok.Str key-str)
            (do
              (match @value
               SheriffTok.Null (put-obj! json obj-i &key-str (SheriffJsonNode.Null))
               (SheriffTok.Str val-str) (put-obj! json obj-i &key-str (SheriffJsonNode.Str val-str))
               (SheriffTok.Bol bol) (put-obj! json obj-i &key-str (SheriffJsonNode.Bol bol))
               (SheriffTok.Num num-str)
               (match (Double.from-string &num-str)
                 (Just num)(put-obj! json obj-i &key-str (SheriffJsonNode.Num num))
                 (Nothing) (set! error (Just @"Number not a valid double")))
               _ (set! error (Just @"Unexpected token in value")))
             (unless (just? &error)
              (match @sep
               (SheriffTok.Comma) (set! i (+ i 4))
               (SheriffTok.RightCurly) (set! i (+ i 4)) 
               _ (set! error (Just @"Expected Comma or RightCurly")))))
            _ (set! error (Just @"Expected key")))
           _ (set! error (Just @"Expected colon")))))
      (match error
        (Nothing)  (Success i)
        (Just err) (Error err))))

  (defn parse-toks [toks]
    (let-do [error (Nothing) json (init []) i 0]
      (while-do (and (< i (Array.length toks))
                     (not (just? &error)))
        (match @(Array.unsafe-nth toks i)
          SheriffTok.Null (ignore (push-jnode! &json (SheriffJsonNode.Null)))
          (SheriffTok.Str st) (ignore (push-jnode! &json (SheriffJsonNode.Str st)))
          (SheriffTok.Num num-str)
          (match (Double.from-string &num-str)
            (Just num) (ignore (push-jnode! &json (SheriffJsonNode.Num num)))
            (Nothing) (set! error (Just @"Number not a valid double")))
          (SheriffTok.Bol boo) (ignore (push-jnode! &json (SheriffJsonNode.Bol boo)))
          SheriffTok.LeftCurly
          (match (parse-object (+ i 1) toks &json)
            (Success new-i) (set! i new-i)
            (Error err) (set! error (Just err)))
          _ (set! error (Just @"Not a valid token")))
        (set! i (inc i)))
      (match error
        (Nothing)  (Success json)
        (Just err) (Error err))))

  (defn parse [s]
    (match (SheriffLexer.lex s)
      (Error err) (Error err)
      (Success tokens) (parse-toks &tokens)))

  (defn get [json s]
    (let [path (String.split-by s &[\.])
          index (Array.reduce
                  &(fn [i path]
                    (if (= path "")
                      i
                      (match @(unsafe-at json i)
                        (SheriffJsonNode.Obj m) (Map.get &m path)
                        _ 0)))
                  0
                  &path)]
      @(unsafe-at json index)))

  (defn get-string [json s]
    (match (get json s)
      (SheriffJsonNode.Str st) (Success st)
      _ (Error (format "Value at '%s' is not a string" s))))

  (defn get-maybe-string [json s]
    (match (get json s)
      (SheriffJsonNode.Str st) (Success (Maybe.Just st))
      SheriffJsonNode.Null (Success (Maybe.Nothing))
      _ (Error (format "Value at '%s' is not a string or null" s))))

  (defn get-number [json s]
    (match (get json s)
      (SheriffJsonNode.Num num) (Success num)
      _ (Error (format "Value at '%s' is not a number" s))))

  (defn get-maybe-number [json s]
    (match (get json s)
      (SheriffJsonNode.Num num) (Success (Maybe.Just num))
      SheriffJsonNode.Null (Success (Maybe.Nothing))
      _ (Error (format "Value at '%s' is not a number or null" s))))

  (defn get-bool [json s]
    (match (get json s)
      (SheriffJsonNode.Bol b) (Success b)
      _ (Error (format "Value at '%s' is not a boolean" s))))

  (defn get-maybe-bool [json s]
    (match (get json s)
      (SheriffJsonNode.Bol b) (Success (Maybe.Just b))
      SheriffJsonNode.Null (Success (Maybe.Nothing))
      _ (Error (format "Value at '%s' is not a boolean or null" s)))))

