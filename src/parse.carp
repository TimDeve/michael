(use Sheriff.JSON.Lexer)
(use Maybe)
(use Result)

(defmodule Sheriff
  (deftype JsonNode
   (Bol [Bool])
   (Str [String])
   (Num [Double])
   (Obj [(Map String Int)])
   (Arr [(Array Int)])
   Null)

  (deftype JSON [data (Array JsonNode)])

  (defmodule JSON
    (defn unsafe-at [json i]
     (Array.unsafe-nth (data json) i))

    (defn push-jnode! [json node]
      (do
       (Array.push-back! (data json) node)
       (- (Array.length (data json)) 1)))

    (defn put-obj! [json obj-i key node]
      (let [new-i (push-jnode! json node) maybe-map (unsafe-at json obj-i)]
        (match-ref maybe-map
          (Sheriff.JsonNode.Obj m)  (Map.put! m key &new-i)
          (Sheriff.JsonNode.Str st) ()
          (Sheriff.JsonNode.Num nu) ()
          (Sheriff.JsonNode.Bol b)  ()
          (Sheriff.JsonNode.Arr a)  ()
          Sheriff.JsonNode.Null     ())))

    (defn parse-object [i toks json]
      (let-do [error (Nothing) obj-i (push-jnode! json (Sheriff.JsonNode.Obj {}))]
        (while-do (and (< i (- (Array.length toks) 3))
                       (not (just? &error)))
          (let [key (Array.unsafe-nth toks i)
                colon (Array.unsafe-nth toks (+ i 1))
                value (Array.unsafe-nth toks (+ i 2))
                sep (Array.unsafe-nth toks (+ i 3))]
            (match @colon
             Token.Colon
             (match @key
              (Token.Str key-str)
              (do
                (match @value
                 (Token.Str val-str) (put-obj! json obj-i &key-str (Sheriff.JsonNode.Str val-str))
                 (Token.Bol bol) (put-obj! json obj-i &key-str (Sheriff.JsonNode.Bol bol))
                 (Token.Num num-str)
                 (match (Double.from-string &num-str)
                   (Just num)(put-obj! json obj-i &key-str (Sheriff.JsonNode.Num num))
                   (Nothing) (set! error (Just @"Number not a valid double")))
                 _ (set! error (Just @"Unexpected token in value")))
               (unless (just? &error)
                (match @sep
                 (Token.Comma) (set! i (+ i 4))
                 (Token.RightCurly) (set! i (+ i 4)) 
                 _ (set! error (Just @"Expected Comma or RightCurly")))))
              _ (set! error (Just @"Expected key")))
             _ (set! error (Just @"Expected colon")))))
        (match error
          (Nothing)  (Success i)
          (Just err) (Error err))))

    (defn parse-toks [toks]
      (let-do [error (Nothing) json (init []) i 0]
        (while-do (and (< i (Array.length toks))
                       (not (just? &error)))
          (match @(Array.unsafe-nth toks i)
            (Token.Str st) (void (push-jnode! &json (Sheriff.JsonNode.Str st)))
            (Token.Num num-str)
            (match (Double.from-string &num-str)
              (Just num) (void (push-jnode! &json (Sheriff.JsonNode.Num num)))
              (Nothing) (set! error (Just @"Number not a valid double")))
            (Token.Bol boo) (void (push-jnode! &json (Sheriff.JsonNode.Bol boo)))
            Token.LeftCurly
            (match (parse-object (+ i 1) toks &json)
              (Success new-i) (set! i new-i)
              (Error err) (set! error (Just err)))
            _ (set! error (Just @"Not a valid token")))
          (set! i (inc i)))
        (match error
          (Nothing)  (Success json)
          (Just err) (Error err))))

    (defn parse [s]
      (match (Lexer.lex s)
        (Error err) (Error err)
        (Success tokens) (parse-toks &tokens)))

    (defn get [json s]
      (let [path (String.split-by s &[\.])
            index (Array.reduce
                    &(fn [i path]
                      (if (= path "")
                        i
                        (match @(unsafe-at json i)
                          (Sheriff.JsonNode.Obj m) (Map.get &m path)
                          _ 0)))
                    0
                    &path)]
        @(unsafe-at json index)))

    (defn get-string [json s]
      (match (get json s)
        (Sheriff.JsonNode.Str st) (Success st)
        _ (Error (format "Value at '%s' is not a string" s))))

    (defn get-number [json s]
      (match (get json s)
        (Sheriff.JsonNode.Num num) (Success num)
        _ (Error (format "Value at '%s' is not a number" s))))

    (defn get-bool [json s]
      (match (get json s)
        (Sheriff.JsonNode.Bol b) (Success b)
        _ (Error (format "Value at '%s' is not a boolean" s))))))

